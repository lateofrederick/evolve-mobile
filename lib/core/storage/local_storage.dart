import 'package:isar/isar.dart';
import 'package:path_provider/path_provider.dart';
import 'dart:convert';

// THIS PART IS GENERATED BY BUILD_RUNNER
// Run: flutter pub run build_runner build
part 'local_storage.g.dart';

@collection
class LocalVisit {
  Id id = Isar.autoIncrement;

  @Index(unique: true, replace: true)
  late String visitId;

  late String clientName;
  late String status; // 'scheduled', 'inProgress', 'completed'
  late DateTime scheduledStart;

  // Store tasks as a JSON list string, e.g. '["task_1", "task_2"]'
  String? completedTasksJson;
}

@collection
class SyncQueueItem {
  Id id = Isar.autoIncrement;

  late String actionType; // 'check_in', 'check_out', 'update_task'
  late String visitId;
  late String payloadJson; // API request body
  late DateTime createdAt;
}

class LocalStorageService {
  late Future<Isar> db;

  LocalStorageService() {
    db = _initDb();
  }

  Future<Isar> _initDb() async {
    final dir = await getApplicationDocumentsDirectory();
    if (Isar.instanceNames.isEmpty) {
      return await Isar.open(
        [LocalVisitSchema, SyncQueueItemSchema],
        directory: dir.path,
      );
    }
    return Isar.getInstance()!;
  }

  // ==========================================
  // VISIT METHODS
  // ==========================================

  Future<void> cacheVisits(List<LocalVisit> visits) async {
    final isar = await db;
    await isar.writeTxn(() async {
      await isar.localVisits.putAll(visits);
    });
  }

  Future<List<LocalVisit>> getCachedVisits() async {
    final isar = await db;
    return isar.localVisits.where().findAll();
  }

  Future<void> updateVisitStatus(String visitId, String status) async {
    final isar = await db;
    await isar.writeTxn(() async {
      final visit = await isar.localVisits.getByVisitId(visitId);
      if (visit != null) {
        visit.status = status;
        await isar.localVisits.put(visit);
      }
    });
  }

  // --- TASK MANAGEMENT (New Method) ---
  Future<void> updateVisitTask(String visitId, String taskId, bool isCompleted) async {
    final isar = await db;
    await isar.writeTxn(() async {
      final visit = await isar.localVisits.getByVisitId(visitId);
      if (visit != null) {
        // 1. Decode existing tasks
        List<String> tasks = [];
        if (visit.completedTasksJson != null) {
          tasks = List<String>.from(jsonDecode(visit.completedTasksJson!));
        }

        // 2. Modify list
        if (isCompleted) {
          if (!tasks.contains(taskId)) tasks.add(taskId);
        } else {
          tasks.remove(taskId);
        }

        // 3. Save back
        visit.completedTasksJson = jsonEncode(tasks);
        await isar.localVisits.put(visit);
      }
    });
  }

  // ==========================================
  // SYNC QUEUE METHODS
  // ==========================================

  Future<void> addToQueue(String actionType, String visitId, Map<String, dynamic> payload) async {
    final isar = await db;
    final item = SyncQueueItem()
      ..actionType = actionType
      ..visitId = visitId
      ..payloadJson = jsonEncode(payload)
      ..createdAt = DateTime.now();

    await isar.writeTxn(() async {
      await isar.syncQueueItems.put(item);
    });
  }

  Future<List<SyncQueueItem>> getQueue() async {
    final isar = await db;
    return isar.syncQueueItems.where().sortByCreatedAt().findAll();
  }

  Future<void> clearQueueItem(int id) async {
    final isar = await db;
    await isar.writeTxn(() async {
      await isar.syncQueueItems.delete(id);
    });
  }
}